import json
import re
import pickle
import numpy as np
import os

# import transformer.Constants as Constants
# !/usr/bin/env python
# -*-encoding:UTF-8 -*-
import database.Constants as Constants

min_time = 1098028800.0
city = Constants.NOW_CITY

group = np.load("Yelp/%s_group.npy" % city)
train_track = np.load("Yelp/%s_train_track.npy" % city)
test_track = np.load("Yelp/%s_test_track.npy" % city)

# ingoing = np.load("Yelp/%s_ingoing.npy" % city)
# outgoing = np.load("Yelp/%s_outgoing.npy" % city)
disc = np.load("Yelp/%s_disc.npy" % city)
user_group = np.load("Yelp/%s_user_group.npy" % city)

train_data = []
test_data = []
# max_type = 999

# tune label and tune actions
labels_ = []
label_ = []
score = []
scores = []
f = open(os.getcwd() + '/Yelp/Yelp_tune.txt', 'r')
line = f.readline()
user_index = 0
tune_action = []
tune_actions = []
while line:
    line = line.split("\n")[0]
    data = line.split("\t")
    # print(user_index,int(data[0] ))
    if user_index != int(data[0]):
        labels_.append(label_)
        scores.append(score)
        user_index += 1
        label_ = []
        score = []

        tune_actions.append(tune_action)
        tune_action = []

    if not label_.__contains__(int(data[1])):
        label_.append(int(data[1]))
        score.append(int(data[2]))

    line = f.readline()
    tune_action.append({'score': int(data[2]),
                             'type_event': int(data[1]),
                             'event_user_group': user_group[int(data[0])]
                             })
labels_.append(label_)
scores.append(score)
f.close()

# test label
f = open(os.getcwd() + '/Yelp/Yelp_test.txt', 'r')
line = f.readline()
user_index = 0
test_label = []
test_labels = []
test_score = []
test_scores = []
while line:
    line = line.split("\n")[0]
    data = line.split("\t")
    # print(user_index,int(data[0] ))
    if user_index != int(data[0]):
        test_labels.append(test_label)
        test_scores.append(test_score)
        user_index += 1
        test_label = []
        test_score = []

    if not label_.__contains__(int(data[1])):
        test_label.append(int(data[1]))
        test_score.append(int(data[2]))

    line = f.readline()

test_labels.append(test_label)
test_scores.append(test_score)
f.close()

actions = []
f = open(os.getcwd() + '/Yelp/Yelp_train.txt', 'r')
line = f.readline()
user_index = 0
while line:
    line = line.split("\n")[0]
    data = line.split("\t")
    # print(user_index,int(data[0] ))
    if user_index != int(data[0]):
        # train_data.append(actions)
        user_index += 1
        len_ = len(actions)

        if len_ >= 10:

            last_ = actions[len_-1]['type_event']
            tuning_label = []
            t = np.zeros(Constants.POI_NUM)

            dis = disc[last_]
            where_ = np.where(dis<20)[0]
            dis = dis[where_]

            for l in actions:
                t += train_track[l['type_event']]
            t = t[where_]

            train_data.append({'actions': actions,'label': labels_[user_index],
                              'score': scores[user_index], 'distance': dis, 'track':t})

            # test data
            tune_action = tune_actions[user_index]
            len_ = len(tune_action)

            last_ = tune_action[len_ - 1]['type_event']
            tuning_label = []

            dis = disc[last_]
            where_ = np.where(dis < 20)[0]
            dis = dis[where_]

            t = np.zeros(Constants.POI_NUM)
            for l in tune_action:
                t += train_track[l['type_event']]

            t = t[where_]

            actions.extend(tune_action)
            test_data.append({'actions': actions,'label': test_labels[user_index],
                              'score': test_scores[user_index], 'distance': dis, 'track':t})

        actions = []

        if user_index % 1000 == 0:
            print(user_index)

    # print(int(data[1]))
    # print((float(data[2])-min_time)/3600000+time_s)

    actions.append({'score': int(data[2]),
                             'type_event': int(data[1]),
                             'event_user_group': user_group[int(data[0])]
                             })
    #                        'type_event': max_type if int(data[1]) > max_type else int(data[1])})


    line = f.readline()
        # break
    # if user_index == 1:
    #     print(train_data)
    #     break

f.close()
#
print('train_data', len(train_data))
print('test_data', len(test_data))
# print(train_data)

# data = {'dim_process': Constants.TYPE_DIMENSION, 'train': train_data[:int(len(train_data)*0.8)]}

# disc = np.load("Yelp/%s_disc.npy" % city)
ingoing = np.load("Yelp/%s_ingoing.npy" % city)
outgoing = np.load("Yelp/%s_outgoing.npy" % city)


# np.random.shuffle(train_data)

with open("Yelp/%s_all_group.pkl" % city, 'rb') as f:
    # data = pickle.load(f, encoding='latin-1')

    data = {'dim_process': Constants.POI_NUM, 'train': train_data,
            # 'num_groups': Constants.NUM_GROUP, 'key_group': data['key_group'], 'value_group': data['value_group'],
            'num_groups': Constants.NUM_GROUP, 'key_group': [], 'value_group': [],
            'group':group, 'ingoing': ingoing, 'outgoing': outgoing}

    # print(data['train'].__len__())

    data_output = open(os.getcwd() + '/Yelp/train_%s.pkl'%city,'wb')
    pickle.dump(data, data_output)
    data_output.close()

    # data_output = open(os.getcwd() + '/data/Yelp/dev.pkl','wb')
    # pickle.dump(train_data, data_output)
    # data_output.close()

    data = {'dim_process': Constants.POI_NUM, 'test': test_data,
            # 'num_groups': Constants.NUM_GROUP, 'key_group': data['key_group'], 'value_group': data['value_group'],
            'num_groups': Constants.NUM_GROUP, 'key_group': [], 'value_group': [],
            'group':group, 'ingoing': ingoing, 'outgoing': outgoing}

    # print(data['train'].__len__())

    data_output = open(os.getcwd() + '/Yelp/test_%s.pkl'%city,'wb')
    pickle.dump(data, data_output)
    data_output.close()
#
# error = []
# f = open(os.getcwd() + '/data/Yelp/Yelp_check_ins_categories.txt', 'w')
# for er in error:
#     f.write(er+"\r\n")
#
# print(len(error))

